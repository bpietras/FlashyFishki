Jako starszy programista frontendu Twoim zadaniem jest stworzenie szczegółowego planu wdrożenia nowego widoku w aplikacji internetowej. Plan ten powinien być kompleksowy i wystarczająco jasny dla innego programisty frontendowego, aby mógł poprawnie i wydajnie wdrożyć widok.

Najpierw przejrzyj następujące informacje:

1. Product Requirements Document (PRD):
<prd>
@.ai/prd.md
</prd>

2. Opis widoku:
<view_description>

### Moduł: Nauka

##### Wybór kategorii do nauki (StudySelectionScreen)
- **Ścieżka widoku**: main/study
- **Główny cel**: Wybór kategorii fiszek do nauki
- **Kluczowe informacje**: Lista kategorii, liczba fiszek do powtórki w każdej kategorii
- **Kluczowe komponenty**:
  - LazyColumn z Card dla każdej kategorii
  - Liczba fiszek do powtórki dla każdej kategorii
  - Button "Rozpocznij naukę" dla każdej kategorii
- **Względy UX/dostępność/bezpieczeństwo**: Wyraźne oznaczenie kategorii bez fiszek do nauki, blokowanie rozpoczęcia nauki dla pustych kategorii

##### Ekran nauki (StudyScreen)
- **Ścieżka widoku**: main/study/{categoryId}
- **Główny cel**: Prezentacja fiszek do nauki i ocena odpowiedzi
- **Kluczowe informacje**: Pytanie, odpowiedź (po obróceniu karty), opcje oceny
- **Kluczowe komponenty**:
  - Swipeable Card z animacją obrotu między pytaniem a odpowiedzią
  - Button "Pokaż odpowiedź"
  - Przyciski "Dobrze" i "Źle" do oceny odpowiedzi
  - LinearProgressIndicator pokazujący postęp sesji
  - Button "Zakończ sesję"
- **Względy UX/dostępność/bezpieczeństwo**: Animacja obrotu karty, wyraźne przyciski oceny

##### Podsumowanie sesji nauki (StudySummaryScreen)
- **Ścieżka widoku**: main/study/{categoryId}/summary
- **Główny cel**: Prezentacja wyników zakończonej sesji nauki
- **Kluczowe informacje**: Liczba przerobionych fiszek, liczba poprawnych i błędnych odpowiedzi
- **Kluczowe komponenty**:
  - Statystyki sesji
  - Wykresy słupkowe i kołowe dla poprawnych/błędnych odpowiedzi
  - Button "Wróć do nauki" i "Zakończ"
- **Względy UX/dostępność/bezpieczeństwo**: Czytelna prezentacja statystyk, intuicyjne opcje dalszych działań


</view_description>

3. User Stories:
<user_stories>

#### US-009: Rozpoczęcie sesji nauki
- Jako zalogowany użytkownik, chcę rozpocząć sesję nauki, aby uczyć się z moich fiszek.
- Kryteria akceptacji:
  1. Użytkownik może wybrać dziedzinę do nauki
  2. System wyświetla fiszki w kolejności od statusu 0 do 2
  3. System nie wyświetla fiszek ze statusem 3 (nauczone)

#### US-010: Przeglądanie fiszki podczas nauki
- Jako uczący się użytkownik, chcę przeglądać fiszki jedna po drugiej, aby efektywnie się uczyć.
- Kryteria akceptacji:
  1. System wyświetla pytanie z fiszki
  2. Użytkownik może wyświetlić odpowiedź po zastanowieniu się
  3. Użytkownik może oznaczyć swoją odpowiedź jako poprawną lub błędną
  4. System aktualizuje status fiszki na podstawie odpowiedzi użytkownika:
     - Poprawna odpowiedź: status fiszki rośnie o 1
     - Błędna odpowiedź: status fiszki spada do 0

#### US-011: Zakończenie sesji nauki
- Jako uczący się użytkownik, chcę zakończyć sesję nauki, aby wrócić do głównego ekranu aplikacji.
- Kryteria akceptacji:
  1. Użytkownik może zakończyć sesję w dowolnym momencie
  2. System zapisuje postępy nauki
  3. System przenosi użytkownika do głównego ekranu aplikacji

#### US-012: Przywrócenie nauczonych fiszek do powtórek
- Jako zalogowany użytkownik, chcę przywrócić nauczone fiszki do powtórek, aby utrwalić wiedzę.
- Kryteria akceptacji:
  1. Użytkownik może wybrać fiszki ze statusem 3 (nauczone)
  2. Użytkownik może zmienić status wybranych fiszek
  3. System aktualizuje status fiszek w bazie danych

</user_stories>

4. Database schema and DAO:
<database_description>
wszystkie klasy w paczce: com.an.intelligence.flashyfishki.domain
</database_description>

5. Tech Stack:
<tech_stack>
@.ai/tech-stack.md
</tech_stack>

Przed utworzeniem ostatecznego planu wdrożenia przeprowadź analizę i planowanie wewnątrz tagów <implementation_breakdown> w swoim bloku myślenia. Ta sekcja może być dość długa, ponieważ ważne jest, aby być dokładnym.

W swoim podziale implementacji wykonaj następujące kroki:
1. Dla każdej sekcji wejściowej (PRD, Opis widoku, User Stories, Database schema and DAO, Tech Stack):
  - Podsumuj kluczowe punkty
 - Wymień wszelkie wymagania lub ograniczenia
 - Zwróć uwagę na wszelkie potencjalne wyzwania lub ważne kwestie
2. Wyodrębnienie i wypisanie kluczowych wymagań z PRD
3. Wypisanie wszystkich potrzebnych głównych komponentów, wraz z krótkim opisem ich opisu, potrzebnych typów, obsługiwanych zdarzeń i warunków walidacji
4. Stworzenie wysokopoziomowego diagramu drzewa komponentów
5. Zidentyfikuj wymagane DTO i niestandardowe typy ViewModel dla każdego komponentu widoku. Szczegółowo wyjaśnij te nowe typy, dzieląc ich pola i powiązane typy.
6. Zidentyfikuj potencjalne zmienne stanu i niestandardowe hooki, wyjaśniając ich cel i sposób ich użycia
7. Wymień wymagane wywołania DAO i odpowiadające im akcje frontendowe
8. Zmapuj każdej historii użytkownika do konkretnych szczegółów implementacji, komponentów lub funkcji
9. Wymień interakcje użytkownika i ich oczekiwane wyniki
10. Wymień warunki wymagane przez DAO i jak je weryfikować na poziomie komponentów
11. Zidentyfikuj potencjalne scenariusze błędów i zasugeruj, jak sobie z nimi poradzić
12. Wymień potencjalne wyzwania związane z wdrożeniem tego widoku i zasugeruj możliwe rozwiązania

Po przeprowadzeniu analizy dostarcz plan wdrożenia w formacie Markdown z następującymi sekcjami:

1. Przegląd: Krótkie podsumowanie widoku i jego celu.
2. Routing widoku: Określenie ścieżki, na której widok powinien być dostępny.
3. Struktura komponentów: Zarys głównych komponentów i ich hierarchii.
4. Szczegóły komponentu: Dla każdego komponentu należy opisać:
 - Opis komponentu, jego przeznaczenie i z czego się składa
 - Główne elementy i komponenty dzieci, które budują komponent
 - Obsługiwane zdarzenia
 - Warunki walidacji (szczegółowe warunki, zgodnie z bazą)
 - Typy wymagane przez komponent
 - Propsy, które komponent przyjmuje od rodzica (interfejs komponentu)
5. Typy: Szczegółowy opis typów wymaganych do implementacji widoku, w tym dokładny podział wszelkich nowych typów lub modeli widoku według pól i typów.
6. Zarządzanie stanem: Szczegółowy opis sposobu zarządzania stanem w widoku, określenie, czy wymagany jest customowy hook.
7. Integracja z bazą: Wyjaśnienie sposobu integracji z dostarczonym punktem końcowym. Precyzyjnie wskazuje typy żądania i odpowiedzi.
8. Interakcje użytkownika: Szczegółowy opis interakcji użytkownika i sposobu ich obsługi.
9. Warunki i walidacja: Opisz jakie warunki są weryfikowane przez interfejs, których komponentów dotyczą i jak wpływają one na stan interfejsu
10. Obsługa błędów: Opis sposobu obsługi potencjalnych błędów lub przypadków brzegowych.
11. Kroki implementacji: Przewodnik krok po kroku dotyczący implementacji widoku.

Upewnij się, że Twój plan jest zgodny z PRD, historyjkami użytkownika i uwzględnia dostarczony stack technologiczny.

Ostateczne wyniki powinny być w języku polskim i zapisane w pliku o nazwie .ai/nauka-view-implementation-plan.md. Nie uwzględniaj żadnej analizy i planowania w końcowym wyniku.

Oto przykład tego, jak powinien wyglądać plik wyjściowy (treść jest do zastąpienia):

```markdown
# Plan implementacji widoku [Nazwa widoku]

## 1. Przegląd
[Krótki opis widoku i jego celu]

## 2. Routing widoku
[Ścieżka, na której widok powinien być dostępny]

## 3. Struktura komponentów
[Zarys głównych komponentów i ich hierarchii]

## 4. Szczegóły komponentów
### [Nazwa komponentu 1]
- Opis komponentu [opis]
- Główne elementy: [opis]
- Obsługiwane interakcje: [lista]
- Obsługiwana walidacja: [lista, szczegółowa]
- Typy: [lista]
- Propsy: [lista]

### [Nazwa komponentu 2]
[...]

## 5. Typy
[Szczegółowy opis wymaganych typów]

## 6. Zarządzanie stanem
[Opis zarządzania stanem w widoku]

## 7. Integracja z bazą
[Wyjaśnienie integracji z dostarczonym bazą, wskazanie typów żądania i odpowiedzi]

## 8. Interakcje użytkownika
[Szczegółowy opis interakcji użytkownika]

## 9. Warunki i walidacja
[Szczegółowy opis warunków i ich walidacji]

## 10. Obsługa błędów
[Opis obsługi potencjalnych błędów]

## 11. Kroki implementacji
1. [Krok 1]
2. [Krok 2]
3. [...]
```

Rozpocznij analizę i planowanie już teraz. Twój ostateczny wynik powinien składać się wyłącznie z planu wdrożenia w języku polskim w formacie markdown, który zapiszesz w pliku .ai/nauka-view-implementation-plan.md i nie powinien powielać ani powtarzać żadnej pracy wykonanej w podziale implementacji.

_________________________________________________________________________________________________________________________________________

Twoim zadaniem jest zaimplementowanie widoku frontendu w oparciu o podany plan implementacji i zasady implementacji. Twoim celem jest stworzenie szczegółowej i dokładnej implementacji, która jest zgodna z dostarczonym planem, poprawnie reprezentuje strukturę komponentów, integruje się z API i obsługuje wszystkie określone interakcje użytkownika.

Najpierw przejrzyj plan implementacji:

<implementation_plan>
@.ai/nauka-view-implementation-plan.md
</implementation_plan>

Wdrażaj plan zgodnie z następującym podejściem:

<implementation_approach>
Realizuj maksymalnie 3 kroki planu implementacji, podsumuj krótko co zrobiłeś i opisz plan na 3 kolejne działania - zatrzymaj w tym momencie pracę i czekaj na mój feedback.
</implementation_approach>

Dokładnie przeanalizuj plan wdrożenia i zasady. Zwróć szczególną uwagę na strukturę komponentów, wymagania dotyczące integracji z bazą i interakcje użytkownika opisane w planie.

Wykonaj następujące kroki, aby zaimplementować widok frontendu:

1. Struktura komponentów:
   - Zidentyfikuj wszystkie komponenty wymienione w planie wdrożenia.
   - Utwórz hierarchiczną strukturę tych komponentów.
   - Upewnij się, że obowiązki i relacje każdego komponentu są jasno zdefiniowane.

2. Integracja z bazą:
   - Zidentyfikuj wszystkie DAO wymienione w planie.
   - Wdróż niezbędne wywołania DAO
   - Obsłuż odpowiedzi z DAO i odpowiednio aktualizacji stan komponentów.

3. Interakcje użytkownika:
   - Wylistuj wszystkie interakcje użytkownika określone w planie wdrożenia.
   - Wdróż obsługi zdarzeń dla każdej interakcji.
   - Upewnij się, że każda interakcja wyzwala odpowiednią akcję lub zmianę stanu.

4. Zarządzanie stanem:
   - Zidentyfikuj wymagany stan dla każdego komponentu.
   - Zaimplementuj zarządzanie stanem przy użyciu odpowiedniej metody (stan lokalny, custom hook, stan współdzielony).
   - Upewnij się, że zmiany stanu wyzwalają niezbędne ponowne renderowanie.

5. Stylowanie i layout:
   - Zastosuj określone stylowanie i layout, jak wspomniano w planie wdrożenia.
   - Zapewnienie responsywności, jeśli wymaga tego plan.

6. Obsługa błędów i przypadki brzegowe:
   - Wdrożenie obsługi błędów dla wywołań DAO i interakcji użytkownika.
   - Rozważ i obsłuż potencjalne edge case'y wymienione w planie.

7. Optymalizacja wydajności:
   - Wdrożenie wszelkich optymalizacji wydajności określonych w planie lub zasadach.
   - Zapewnienie wydajnego renderowania i minimalnej liczby niepotrzebnych ponownych renderowań.

8. Testowanie:
   - Jeśli zostało to określone w planie, zaimplementuj testy jednostkowe dla komponentów i funkcji.
   - Dokładnie przetestuj wszystkie interakcje użytkownika i integracje API.

W trakcie całego procesu implementacji należy ściśle przestrzegać dostarczonych zasad implementacji. Zasady te mają pierwszeństwo przed wszelkimi ogólnymi najlepszymi praktykami, które mogą być z nimi sprzeczne.

Upewnij się, że twoja implementacja dokładnie odzwierciedla dostarczony plan implementacji i przestrzega wszystkich określonych zasad. Zwróć szczególną uwagę na strukturę komponentów, integrację API i obsługę interakcji użytkownika.
